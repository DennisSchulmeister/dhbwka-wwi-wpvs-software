<!-- ============ -->
<!-- Referenzteil -->
<!-- ============ -->
<section data-chapter data-title="Referenzteil"></section>

<!-- ––––––––––––––––––––––––––––––––––––– -->
<!-- Änderungen an der TomEE-Konfiguration -->
<!-- ––––––––––––––––––––––––––––––––––––– -->
<section data-title="Änderungen an der TomEE-Konfiguration">
    <p>
        Wenn du die vorkonfigurierte Version von Apache TomEE und Apache Derby von Moodle
        heruntergeladen hast, kannst du diese Seite übergehen. An dieser Stelle sind nur
        die Einstellungen dokumentiert, die wir gegenüber der Basisversion von TomEE
        verändert haben.
    </p>

    <h3>Hinzufügen des Derby JDBC-Treibers</h3>
    <p>
        Im <span class="fn">lib</span>-Verzeichnis wurde die Datei <span class="fn">derbyclient.jar</span>
        mit dem JDBC-Treiber für Derby hinzugefügt. Die Datei ist in der Derby-Distribution vorhanden.
    </p>
    <figure>
        <img src="img/referenz/derbyclient.png" />
        <figcaption>
            JDBC-Treiber der Derby-Datenbank im <span class="fn">lib</span>-Verzeichnis von TomEE
        </figcaption>
    </figure>

    <h3>Definition der Datenbankverbindung</h3>
    <p>
        In der Datei <span class="fn">conf/tomee.xml</span> wurden zwei JNDI-Ressourcen für die
        Datenbankverbindungen hinterlegt. Gemäß Empfehlung aus dem Internet, wurde dabei sowohl
        eine <span class="scr">managed</span> als auch eine <span class="scr">unmanaged</span>
        Verindung definiert. Diese Verbindungen werden von allen Beispiel-Anwendungen verwendet
        und sind identisch zu der Version in NetBeans.
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;?xml version="1.0" encoding="UTF-8"?&gt;
            &lt;tomee&gt;
                &lt;Resource id="Default-Database-Managed" type="javax.sql.DataSource"&gt;
                  JdbcDriver = org.apache.derby.jdbc.ClientDriver
                  JdbcUrl    = jdbc:derby://localhost:1527/sample
                  UserName   = app
                  Password   = app
                  JtaManaged = true
                &lt;/Resource&gt;

                &lt;Resource id="Default-Database-Unmanaged" type="javax.sql.DataSource"&gt;
                  JdbcDriver = org.apache.derby.jdbc.ClientDriver
                  JdbcUrl    = jdbc:derby://localhost:1527/sample
                  UserName   = app
                  Password   = app
                  JtaManaged = false
                &lt;/Resource&gt;
            &lt;/tomee&gt;
        </code>
    </pre>

    <h3>Zulassen gesicherter HTTPS-Verbindungen</h3>
    <p>
        Einige Beispiele in „Verteilte Systeme” zeigen, wie in der <span class="fn">web.xml</span>
        eine gesicherte HTTPS-Verbindung erzwungen werden kann, damit sensible Daten nicht unverschlüsselt
        übertragen werden. Leider ist SSL in der Standardkonfiguration von TomEE aber nicht aktiviert und
        es wird auch nicht einmal ein selbst-signiertes Serverzertifikat mitgeliefert. Folgende Zeilen
        wurden deshalb in der <span class="fn">conf/server.xml</span> eingefügt. Der Kommentar beschreibt
        dabei auch gleich, wie das selbst-signierte Zertifikat erzeugt wurde.
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;Server port="8005" shutdown="SHUTDOWN"&gt;
                …
                &lt;Service name="Catalina"&gt;
                    …
                    &lt;Connector
                        protocol   = "HTTP/1.1"
                        port       = "8443"
                        maxThreads = "150"
                        SSLEnabled = "true"
                    &gt;
                        &lt;UpgradeProtocol
                            className  = "org.apache.coyote.http2.Http2Protocol"
                            xpoweredBy = "true"
                            server     = "Apache TomEE"
                        /&gt;
                        &lt;SSLHostConfig&gt;
                            &lt;!-- Vgl. https://tomcat.apache.org/tomcat-9.0-doc/ssl-howto.html (sehr gute Doku!)           --&gt;
                            &lt;!-- Vgl. https://tomcat.apache.org/tomcat-9.0-doc/config/http.html#SSL_Support_-_Certificate --&gt;
                            &lt;!--                                                                                          --&gt;
                            &lt;!-- Kommando zum Erzeugen der Keystore-Datei:                                                --&gt;
                            &lt;!-- keytool -genkey -alias tomcat -keyalg RSA -keystore localhost-rsa.jks -validity 7300     --&gt;
                            &lt;!--         -ext SAN=DNS:localhost -ext KU=digitalSignature -ext EKU=serverAuth              --&gt;
                            &lt;!--                                                                                          --&gt;
                            &lt;!-- Mit folgenden Angaben:                                                                   --&gt;
                            &lt;!-- CN=localhost, OU=Studiengang Wirtschaftsinformatik, O=DHBW Karlsruhe, L=Karlsruhe,       --&gt;
                            &lt;!-- ST=Baden-Württemberg, C=DE                                                               --&gt;
                            &lt;!--                                                                                          --&gt;
                            &lt;!-- Zertifikat dann exportiert mit:                                                          --&gt;
                            &lt;!-- keytool -keystore localhost-rsa.jks -exportcert -alias tomcat -rfc -file localhost.crt   --&gt;
                            &lt;!--                                                                                          --&gt;
                            &lt;!-- Passwort dabei immer:                                                                    --&gt;
                            &lt;!-- password                                                                                 --&gt;
                            &lt;Certificate
                                certificateKeystoreFile     = "conf/localhost-rsa.jks"
                                certificateKeystorePassword = "password"
                                type                        = "RSA"
                                xpoweredBy                  = "true"
                                server                      = "Apache TomEE"
                            /&gt;
                        &lt;/SSLHostConfig&gt;
                    &lt;/Connector&gt;
                    …
                &lt;/Service&gt;
            &lt;/Server&gt;
        </code>
    </pre>

    <h3>Hinzufügen der Rolle „manager-gui” für Benutzer „admin”</h3>
    <p>
        Dies ist für die Vorlesung nicht so wichtig. Jedoch wurde in der Datei <span class="fn">conf/tomcat-users.xml</span>
        der bereits vordefinierte Benutzer „admin” der Rolle „manager-gui” hinzugefügt. Somit kann bei Bedarf die Weboberfläche
        zur Administration des Servers gestartet werden.
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;tomcat-users&gt;
                …
                &lt;user password="admin" roles="manager-script,admin,manager-gui" username="admin"/&gt;
            &lt;/tomcat-users&gt;
        </code>
    </pre>

    <h3>Zulassen von AJAX-Verbindungen auf fremde Domains</h3>
    <p>
        Gemäß Same-Origin-Policy erlauben moderne Browser keine AJAX-Zugriffe auf fremde Domains mehr, wenn dies nicht vom
        ausliefernden Webserver der Seite explizit erlaubt wird. Damit aber weiterhin AJAX-Zugriffe in den Beispielen und
        Aufgaben von „Webprogrammierung” und „Verteilte Systeme” möglich sind, wurden in der Datei <span class="fn">conf/web.xml</span>
        folgende Zeilen hinzugefügt, die einen Zugriff auf sämtliche, fremde Domains pauschal erlauben.
    </p>
    <pre data-gobble>
        <code class="html" data-gobble>
            &lt;web-app&gt;
                &lt;filter&gt;
                    &lt;filter-name&gt;CorsFilter&lt;/filter-name&gt;
                    &lt;filter-class&gt;org.apache.catalina.filters.CorsFilter&lt;/filter-class&gt;
                    &lt;init-param&gt;
                        &lt;param-name&gt;cors.allowed.origins&lt;/param-name&gt;
                        &lt;param-value&gt;*&lt;/param-value&gt;
                    &lt;/init-param&gt;
                    &lt;init-param&gt;
                        &lt;param-name&gt;cors.allowed.methods&lt;/param-name&gt;
                        &lt;param-value&gt;GET,PUT,POST,PATCH,DELETE,HEAD,OPTIONS&lt;/param-value&gt;
                    &lt;/init-param&gt;
                    &lt;init-param&gt;
                        &lt;param-name&gt;cors.allowed.headers&lt;/param-name&gt;
                        &lt;param-value&gt;Content-Type,X-Requested-With,accept,Origin,Access-Control-Request-Method,Access-Control-Request-Headers&lt;/param-value&gt;
                    &lt;/init-param&gt;
                    &lt;init-param&gt;
                        &lt;param-name&gt;cors.exposed.headers&lt;/param-name&gt;
                        &lt;param-value&gt;Access-Control-Allow-Origin,Access-Control-Allow-Credentials&lt;/param-value&gt;
                    &lt;/init-param&gt;
                &lt;/filter&gt;
                &lt;filter-mapping&gt;
                    &lt;filter-name&gt;CorsFilter&lt;/filter-name&gt;
                    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
                &lt;/filter-mapping&gt;
                …
            &lt;/web-app&gt;
        </code>
    </pre>

    <h3>Erhöhung des Log-Levels für Realm-Fehler</h3>
    <p>
        In den Beispielen für „Verteilte Systeme” wird auch gezeigt, wie ein datenbankgestütztes Anmeldeverfahren
        in eigenen Webanwendungen realisiert werden kann. Dabei sind Fehler in der Programmierung aber leider nicht
        immer von schlichten Eingabefehlern bei der Anmeldung zu unterscheiden. Falls dies der Fall ist, können in
        der Datei <span class="fn">conf/logging.properties</span> folgende Zeilen einkommentiert werden, um den
        Log-Level zu erhöhen:
    </p>
    <pre data-gobble>
        <code data-gobble>
            # Log-Meldungen für Auth-Versuche in den Anwendungen
            # Vgl. http://dev-answers.blogspot.com/2010/03/enable-debugtrace-level-logging-for.html
            #org.apache.catalina.realm.level = ALL
            #org.apache.catalina.realm.useParentHandlers = true
            #org.apache.catalina.authenticator.level = ALL
            #org.apache.catalina.authenticator.useParentHandlers = true
        </code>
    </pre>

    <h3>Vermeidung von Namenskollisionen gleichnamiger EJBs</h3>
    <p>
        Die Standardkonfiguration von TomEE lässt es nicht zu, dass zwei Webanwendungen unterschiedliche Enterprise
        Java Beans mit gleichem Namen beinhalten. Dies steht im Kontrast zu den meisten anderen EJB-Containern wie
        GlassFish oder WildFly, die damit keine Probleme haben. Aus diesem Grund kann in TomEE normalerweise eine
        Anwendung nicht deployed werden, wenn es bereits eine andere Anwendung mit gleichnamigen EJBs gibt. Natürlich
        kommt aber genau dies in unseren Beispielen vor, da die Beispiele oft ja nur Variationen desselben Themas sind.
        Aus diesem Grund wurden in der Datei <span class="fn">conf/system.properties</span> folgende Zeile hinzugefügt,
        um das Verhalten von TomEE an die anderen Server anzugleichen. Dadurch wird der Name der umgebenden Anwendung
        Teil des globalen EJB-Namens.
    </p>
    <pre data-gobble>
        <code data-gobble>
        openejb.deploymentId.format = {ejbJarId}/{ejbName}
        </code>
    </pre>
</section>
